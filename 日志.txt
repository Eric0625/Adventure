2016.04.01
至今完成的部分：文字消息显示的处理，战斗引擎，人物，技能，装备，状态（部分），人物已经可以打斗，信息输出也已经比较完整
2016.04.02
今天完成了房间的部分功能，已可以通过类实现静态房间，但仍需要考虑房间的动态生成，并将之作为主要的房间生成方式。另外，还有气候，特殊房间模板，人物走动，房间销毁与再生，房间机关触发等等需要考虑。初步考虑用xml文件作为
描述动态房间的格式
2016.04.03
加入NPC动态说话，从此人物有了生气
将玩家类和人形NPC分开来，虽然具备共同的特性如肢体，默认动作，但NPC还有不同的行为特征，并且存在非人形NPC，所以必须有两个不同的继承方向，目前的继承树如下：
KCharacter（生物）：会战斗的任何物体
/                                 \
KUser（玩家）：需要互动的对象                       KNPC（电脑控制的生物）：需要自动行走，聊天和出发互动
/               |              \
KPerson（人形生物）       KBeast          KDragon等等
2016.04.04
01:22 在复制NPC上遇到重大困难，应该使用构造函数复制还是clone？
10:09 决定使用clone，因为构造函数无法读取源的私有成员复制
实现了所有需要的clone函数，并增加KEntity类作为实体类的根，其它skill等类均为非实体类
今天实现了房间的动态加载，实现了所有需要复制的类的clone函数，目前看来运作良好
下一步：实现NPC的随机走动，添加一个区域。
最艰难的部分似乎已经跨过
2016.04.05
建立新的房间检索机制，通过建立房间名字典，以字符串为桥梁，在代码中以字符串形式初始化区域，这样要好于直接用数字
2016.04.06
在物品和人物检索中尝试使用枚举，这有可能会在数量较多时出现问题。
实现了人物点击的互动
目前需要完成的：NPC的刷新，尸体的生成，物品的拾取，物品的重量，物品嵌套
2016.04.07
生成尸体时需要解决物品在容器间移动的问题，由此需要解决容器嵌套和移动函数的重构，不是个简单的问题
已解决嵌套，下一步完全实现物品移动
2016.04.08
实现了物品的点击互动
将物品的移动函数重构到kentity类中，并实现物品的完全嵌套，物品重量和拾取已实现，拾取还差容器的
取消了单个的物品装备位置指针，改用装备位枚举标志标识，缺点是每次获取特定部位装备都需要检索Inventory，但好处
是在克隆时不会存在可能的错误克隆（如左戒指克隆到右戒指上）
现在应该可以生成尸体了
下一步装备武器
2016.04.09
有必要规范一下函数，变量名称，函数应该带有动词，并能和参数形成谓宾结构，变量应该为名词，私有变量前缀下划线，公有变量第一个字母大写
实现容貌，完善颜色代码
实现NPC死亡，考虑如何实现定时刷新
2016.04.10
实现NPC刷新，但会显示“……走了过来”，是否处理呢（已处理）
2016.04.11
实现房间物品刷新机制，比想象的复杂得多
下一步方向：实现金钱，物品交易
2016.04.12
实现金钱类，为虚类，与int互相隐式转换
实现物品交易，商人的负重无限大，卖价比率拟合值：7,25;15,40;20,50;25,60;27,80;30,85;35,100，前一个数字为口才，后一个为比率*100
下一步实现：使用者死亡，物品属性加成
人物属性（属性点总数）生成应服从正态分布
2016.04.14
人物属性点如果是动态的，玩家会不停选择以得到更好的，所以应为固定值
2016.04.26
迁移到swift上，比较重大的改动是clone方法变为构造器克隆，对象的构造由顶向下改为由下向顶，因为并没有memberwize方法可以调用
克隆的过程：类调用自身的带自身类型参数的构造器，获得一个克隆过的对象，该构造器为required并独立于其它构造器，因为一个属性在
克隆时的赋值与新建时的赋值并不能等同，所以不应该调用其它构造器，也就是说克隆构造器不应是一个便利构造器
2016.04.27
KObject现在支持Hashable协议
2016.04.29
逐渐移植代码中，其中重要的变化是去除了money类，改用extension扩展Int类型；将rivalList由array改为set
2016.04.30, 05.01
继续移植
2016.05.04
代码移植完成，纠正编译错误中
2016.05.06
通过init方式克隆会导致一个问题：在拷贝子类时，由于无法动态获取子类名称，所以只能克隆成基类，如存在一个KLibai_City对象，当要克隆时，程序只知道该对象的ID（npcnames.李白)以及基类KNPC，当用KNPC的构造函数克隆时，只能
得到一个具备基本属性的KNPC对象。
Clone方法则不存在这个问题，因为KLiBai_city的Clone方法知道该生成什么对象，即使该方法是通过downcast成KNPC后再调用的
将KRoom的物品和npc生成方式改为：定义[字符串:数量]字典，通过nsstringfromclass（）写入该房间要载入的npc类和数量，在实现时，利用NSClassFromString(v) as? KNPC.Type生成type，并调用KNPC.init函数生成对象
房间物品刷新时，也利用NSClassFromString生成KItem.Type，并调用Init函数，此时，物品的Init函数能正确被调用
2016.05.13
改变command的枚举为符合optionsettype的结构
2016.05.20
解决了颜色代码的解析问题